# 资源状态管理 Skill

此 Skill 规范了系统中“禁用/启用”、“锁定/解锁”等资源状态管理的统一实现方式。

## 1. 业务术语规范

- **Inactive (禁用/锁定)**：使资源变为不可用状态。常用路由动作：`lock`, `disable` 或 `inactive`。
- **Activate (启用/激活)**：使资源恢复为可用状态。常用路由动作：`unlock`, `enable` 或 `active`。

## 2. 领域模型实现

### 2.1 状态值对象 (Value Object)
推荐为资源状态创建一个专用的值对象类。

```csharp
public sealed record [基础类名]Status
{
    public static readonly [基础类名]Status Active = new [基础类名]Status("ACTIVE", "启用");
    public static readonly [基础类名]Status Inactive = new [基础类名]Status("INACTIVE", "禁用");

    public string Code { get; }
    public string Description { get; }

    private [基础类名]Status(string code, string description)
    {
        Code = code;
        Description = description;
    }

    public static [基础类名]Status FromCode(string code) => code switch
    {
        "ACTIVE" => Active,
        "INACTIVE" => Inactive,
        _ => throw new ArgumentException($"Invalid status code: {code}")
    };
}
```

### 2.2 聚合根方法
聚合根应提供明确的语义化方法来切换状态，并发布领域事件。

```csharp
public class [基础类名] : AggregateBase
{
    public [基础类名]Status Status { get; private set; }

    public void Inactive()
    {
        if (this.Status == [基础类名]Status.Inactive) return;
        this.Status = [基础类名]Status.Inactive;
        RegisterEvent(new [基础类名]StatusModifiedEvent(this.Id.id, this.Status.Code));
    }

    public void Activate()
    {
        if (this.Status == [基础类名]Status.Active) return;
        this.Status = [基础类名]Status.Active;
        RegisterEvent(new [基础类名]StatusModifiedEvent(this.Id.id, this.Status.Code));
    }
}
```

## 3. 应用层实现

### 3.1 命令类 (Command)
状态切换通常只需要 ID。

```csharp
public sealed record Inactive[基础类名]Command(long Id) : ICommand<Result>;
public sealed record Activate[基础类名]Command(long Id) : ICommand<Result>;
```

### 3.2 处理器 (Handler)
Handler 负责加载聚合根、调用状态切换方法并持久化。

```csharp
public async Task<Result> HandleAsync(Inactive[基础类名]Command command, CancellationToken ct)
{
    var aggregate = await _repository.LoadAsync(command.Id);
    if (aggregate == null) return Result.Fail("Resource.NotFound", "资源不存在");
    
    aggregate.Inactive();
    
    await _repository.SaveAsync(aggregate);
    await _outboxRepository.AddAsync(aggregate.GetRegisteredEvents(), ...);
    
    return Result.Ok();
}
```

## 4. API 路由规范

为了保持 RESTful 风格的一致性，推荐使用以下路由设计：

- **禁用/锁定**：`POST /prefix/{id}/lock` (使用 POST 表示一种原子操作更改)
- **启用/激活**：`DELETE /prefix/{id}/lock` (使用 DELETE 表示解除锁定状态)

```csharp
[HttpPost("{id:long}/lock")]
public async Task<IActionResult> Inactive([FromRoute] long id) 
{
    // ... 执行 Inactive[基础类名]Command
}

[HttpDelete("{id:long}/lock")]
public async Task<IActionResult> Activate([FromRoute] long id)
{
    // ... 执行 Activate[基础类名]Command
}
```
