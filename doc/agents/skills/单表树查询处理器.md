## 单表树查询处理器

本文档介绍单表树查询处理器的设计与实现，旨在帮助开发者理解其工作原理及应用场景。

以下概念定义由调用者提供：
- [数据库表名] : Mysql数据库表名，数据库表完整定义位于`doc/database/schema.sql`, 可根据表名进行寻找，表名由此Skill的用户在调用时指定。
- [基础类名] : 表示为此Skill中要创建的模型，命令，Handler等类名称的动态部分，由此Skill的用户在调用时制定。
- [领域名] : 表述应用层逻辑所属的领域名称，由此Skill的用户在调用时指定。
- [传输对象名] : 表示树节点的数据传输对象。

MySql单表存在以下字段：

```mysql
`id`           BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT 'ID',
`parent_id`    BIGINT       NOT NULL DEFAULT 0 COMMENT '父ID',
```

其中，`id`字段为节点的唯一标识，`parent_id`字段表示节点的父节点ID。通过这两个字段，可以构建出树形结构的数据关系。

按照以下步骤实现单表树查询处理器：

### 1 定义Dto

按以下规则进行创建：
- 类名：`[基础类名]TreeNodeDto`
- 位置：`src/core/Renligou.Core.Application/[领域名]/Queries`
- 实现：应实现为`sealed record`
- 属性：
  - `Id` : `long`类型，表示节点ID。
  - `ParentId` : `long`类型，表示父节点ID。
  - 其他业务相关属性。
- 必须添加属性：
  - `List<[传输对象名]> Children` : 用于存储子节点的列表。
- 用[Description]属性对类及属性进行注释, 编译时生成文档。 

参考如下示例：
```csharp
public sealed record CategoryTreeNodeDto
{
    [Description("节点ID")]
	public long Id { get; init; }

	[Description("父节点ID")]
	public long ParentId { get; init; }

	[Description("节点名称")]
	public string Name { get; init; } = String.Empty;

	[Description("子节点列表")]
	public List<CategoryTreeNodeDto> Children { get; init; } = new();
}
```

### 2 定义查询命令

按以下规则进行创建：
- 类名：`Get[基础类名]TreeQuery`
- 位置：`src/core/Renligou.Core.Application/[领域名]/Queries`
- 实现：应实现为`sealed record`
- 继承：应继承自`IQuery<List<[传输对象名]>>`
- 属性：
  - `long ParentId` : 用于搜索父节点。
  -  如果数据库表后缀中包含name后缀，则添加`string? Name`属性，用于按名称模糊搜索。

参考如下：
```csharp
public sealed record GetCategoryTreeQuery : IQuery<List<CategoryTreeNodeDto>>
{
	public long ParentId { get; init; }
	public string? Name { get; init; }
}
```
### 3 定义Criteria类
按以下规则进行创建：
- 类名：`[基础类名]TreeCriteria`
- 位置：`src/core/Renligou.Core.Application/[领域名]/Criterias`
- 实现：应实现为`sealed record`
参考示例：
```csharp
public sealed record CategoryTreeCriteria
{
	public long ParentId { get; init; }
	public string? Name { get; init; }
}
```

### 4 定义查询Repository接口

按以下规则进行创建, 如果查询Repository接口已存在，则向其中添加方法：

- 接口名：`I[基础类名]QueryRepository`
- 位置：`src/core/Renligou.Core.Application/[领域名]/Queries`
- 必须继承IRpository接口

参考示例：
```csharp
public interface ICategoryQueryRepository : IRepository
{
	Task<List<CategoryTreeNodeDto>> GetCategoryTreeAsync(CategoryTreeCriteria criteria, CancellationToken cancellationToken);
}
```

### 5 实现查询Repository
按以下规则进行创建, 如果查询Repository实现类已存在，则向其中添加方法：
- 类名：`[基础类名]QueryRepository`
- 位置：`src/infrastructure/Renligou.Infrastructure.Persistence/Repos`
- 必须实现`I[基础类名]QueryRepository`接口
- 方法实现：
  - 将Criteria转换为查询条件。
  - 如果数据库表包含`deleted_at`字段，只查deleted_at=0的记录。
  - 查询所有结果后，构建树形结构。
	
### 6 实现查询处理器
按以下规则进行创建：
- 类名：`Get[基础类名]TreeHandler`
- 位置：`src/core/Renligou.Core.Application/[领域名]/Handlers`
- 必须实现`IQueryHandler<Get[基础类名]TreeQuery, List<[传输对象名]>>`接口
- 方法实现：
  - 将查询命令转换为Criteria。
  - 调用查询Repository获取数据。
  - 返回结果。

参考示例：
```csharp
public sealed class GetCategoryTreeHandler(
    ICategoryQueryRepository _categoryQueryRepository
): IQueryHandler<GetCategoryTreeQuery, List<CategoryTreeNodeDto>>
{
	public async Task<List<CategoryTreeNodeDto>> Handle(GetCategoryTreeQuery request, CancellationToken cancellationToken)
	{
		var criteria = new CategoryTreeCriteria
		{
			ParentId = request.ParentId,
			Name = request.Name
		};
		var nodes = await _categoryQueryRepository.GetCategoryTreeAsync(criteria, cancellationToken);
		return nodes;
	}

}
```